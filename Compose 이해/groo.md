# Compose 이해 - groo
## 선언형 프로그래밍 패러다임
- 일반적으로 업데이트가 필요한 뷰의 수가 많을수록 소프트웨어 유지관리 복잡성이 증가한다.
- Compose는 특정 시점에 UI의 어떤 부분을 다시 그려야 하는지를 지능적으로 선택한다.

## 간단한 구성 가능한 함수
- UI를 내보내는 Compose 함수는 UI 위젯을 구성하는 대신 원하는 화면을 설명하므로 아무것도 반환할 필요가 없다.
- 함수는 동일한 인수로 여러 번 호출될 때 동일한 방식으로 작동하며, 전역 변수 또는 random() 호출과 같은 다른 값을 사용하지 않습니다.
- 함수의 속성 또는 전역 변수 수정과 같은 부작용 없이 UI를 형성한다.

## 선언형 패러다임 전환
- Compose의 선언형 접근 방식에서 위젯은 비교적 스테이트리스(Stateless) 상태이며 setter 또는 getter 함수를 노출하지 않습니다.
- 사실상 위젯은 객체로 노출되지 않습니다.
- 동일한 구성 가능한 함수를 다른 인수로 호출하여 UI를 업데이트 합니다.

## 재구성
- 공유 객체의 속성에 쓰기
- ViewModel에서 식별 가능한 요소 업데이트
- 공유 환경설정 업데이트
- 구성 가능한 함수는 순서와 관계없이 실행될 수 있다.
- 구성 가능한 함수는 동시에 실행할 수 있다.
- 재구성은 최대한 많은 수의 구성 가능한 함수 및 람다를 건너뛴다.
- 재구성은 낙관적이며 취소될 수 있다.
- 구성 가능한 함수는 애니메이션의 모든 프레임에서와 같은 빈도로 매우 자주 실행될 수 있다.

### 구성 가능한 함수는 순서와 관계없이 실행될 수 있음
- 구성 가능한 함수에 다른 구성 가능한 함수 호출이 포함되어 있다면 그 함수는 순서와 관계없이 실행될 수 있다.
- Compose에는 일부 UI 요소가 다른 UI 요소보다 우선순위가 높다는 것을 인식하고 그 요소를 먼저 그리는 옵션이 있다.

### 구성 가능한 함수는 동시에 실행할 수 있음
- 애플리케이션이 올바르게 작동하려면 모든 구성 가능한 함수에 부작용이 없어야 한다.
- 대신 UI 스래드에서 항상 실행되는 onClick과 같은 콜백에서 부작용을 트리거 한다.

### 재구성은 낙관적임
- 낙관적 재구성을 처리할 수 있도록 모든 구성 가능한 함수 및 람다가 멱등원이고 부작용이 없는지 확인해야 한다.
