## Jetpack Compose 단계
Android View 시스템에는 측정, 레이아웃, 그리기라는 세 가지 주요 단계가 있습니다.  
Compose도 매우 비슷하지만 시작 부분에 컴포지션이라는 중요한 단계가 더 있습니다.  

### 프레임의 세 단계
컴포지션: 표시할 UI입니다. 구성 가능한 함수를 실행하고 UI 설명을 만듭니다.  
레이아웃: UI를 배치할 위치입니다. 이 단계는 측정과 배치라는 두 단계로 구성됩니다. 레이아웃 요소는 레이아웃 트리에 있는 각 노드의 레이아웃 요소 및 모든 하위 요소를 2D 좌표로 측정하고 배치합니다.  
그리기: UI를 렌더링하는 방법입니다. UI 요소는 일반적으로 기기 화면인 캔버스에 그려집니다.  
</br>
컴포지션 > 레이아웃(측정, 배치) > 그리기  
단방향 데이터 흐름으로 UI가 그려집니다.  
</br>
Compose는 성능을 위해 모든 단계에서 같은 입력 데이터로 같은 결과를 계산하는 반복 작업을 피합니다.  
Compose는 이전 결과를 재사용할 수 있으면 구성 가능한 함수 실행을 건너뛰고 Compose UI는 꼭 필요한 경우가 아니라면 전체 트리를 다시 배치하거나 다시 그리는 작업을 하지 않습니다.  
이러한 최적화가 가능한 이유는 Compose가 여러 단계 내에서 상태 읽기를 추적하기 때문입니다.  

### 상태 읽기
Compose는 상태 값을 읽을 때 실행하던 작업을 자동으로 추적합니다.  
getter와 setter 함수는 속성을 값으로 참조할 때만 호출되고 속성이 만들어질 때는 호출되지 않습니다.  

### 단계적 상태 읽기
Compose는 각 단계에서 상태를 추적합니다.  
이를 통해 Compose는 영향을 받는 각 UI 요소에서 작업을 실행해야 하는 특정 단계만 알릴 수 있습니다.  

#### 1단계: 컴포지션
컴포저블 함수나 람다 블록 내의 상태 읽기는 컴포지션 및 잠재적으로 이후 단계에서 영향을 미칩니다.  
상태 값이 변경되면 Recomposer는 이 상태 값을 읽는 모든 구성 가능한 함수의 재실행을 예약합니다.  
콘텐츠가 동일하게 유지되고 크기와 레이아웃이 변경되지 않으면 컴포지션 단계를 건너뛸 수 있습니다.  

#### 2단계: 레이아웃
측정 단계에서는 Layout 컴포저블에 전달된 측정 람다와 LayoutModifier 인터페이스의 MeasureScope.meausre 메서드 등을 실행합니다.  
배치 단계에서는 layout 함수의 배치 블록과 Modifier.offset의 람다 블록 등을 실행합니다.  
상태 값이 변경되면 Compose UI는 레이아웃 단계를 예약합니다.  
크기나 위치가 변경된 경우 그리기 단계도 실행합니다.  
측정 단계와 배치 단계의 다시 시작 범위는 별개이므로 배치 단계의 상태 읽기가 그 전 측정 단계를 다시 호출하지 않습니다.  
그러나 이 두 단계는 서로 관련된 경우가 많으므로 배치 단계의 상태 읽기가 측정 단계에 속하는 다른 다시 시작 범위에 영향을 미칠 수 있습니다.  

### 상태 읽기 최적화
Compose는 현지화 된 상태 읽기 추적을 실행하므로 적절한 단계에서 각 상태를 읽어 실행하는 작업량을 최소화할 수 있습니다.  
그러나 이 예에서는 모든 스크롤로 인해 전체 구성 가능한 콘텐츠가 재평가된 후 측정되고 배치되며 최종적으로 그려지기 때문에 바람직하지는 않습니다.  
Google에서는 표시하는 항목이 변경되지 않고 표시되는 위치만 변경되었더라도 모든 스크롤에서 Compose 단계를 트리거합니다.  
수정자에 제공하는 람다 블록은 레이아웃 단계(특히 레이아웃 단계의 배치 단계)에서 호출됩니다.  
람다 매개변수를 사용하면 추가 비용이 발생합니다.  
상태 읽기를 가능한 가장 낮은 단계로 현지화하여 Compose에서 최소한의 작업을 실행할 수 있도록 한다는 일반적인 개념도 사실입니다.  
물론 컴포지션 단계에서 상태를 읽는 것이 꼭 필요한 경우도 많습니다.  
그렇더라도 상태 변경을 필터링하여 리컴포지션 수를 최소화 할 수 있는 경우도 있습니다.  

### 리컴포지션 루프(순환 단계 종속 항목)
이 예에서 문제는 단일 프레임 내에서 '최종' 레이아웃에 도달하지 않는다는 점입니다.  
여기서 일반적인 원칙은 서로에 관해 측정하고 배치해야 하는 여러 UI 요소의 단일 소스 저장소를 보요하는 것입니다.  
적절한 레이아웃 프리미티브를 사용하거나 맞춤 레이아웃을 만들면 최소 공유 상위 요소가 여러 요소 간의 관계를 조정할 수 있는 정보 소스 역할을 합니다.  
동적 상태를 도입하면 이 원칙이 깨집니다.  