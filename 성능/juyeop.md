## Compose 성능
<b>Date</b> - Oct. 1th. 2022  
<b>Author</b> - Juyeop  

### 출시 모드에서 빌드 및 R8 사용
성능 문제를 발견하면 앱을 release 모드로 실행해봐라.  
release 모드에서는 자동으로 R8 컴파일러가 사용된다.  

### 기준 프로필 사용
Android 플랫폼 코드는 이미 컴파일되어 기기에 설치되어 있다.  
반면 라이브러리는 앱이 실행될 때 로드되고 기능이 필요할 때 just-in-time 방식으로 해석되어야 한다.  
기준 프로필을 정의하여 성능을 개선할 수 있다.  
이러한 프로필은 중요한 사용자 여정에 필요한 클래스와 메서드를 정의하고 앱의 APK와 함께 배포된다.  
앱 설치 중에 ART는 중요한 코드를 ahead-of-time 방식으로 컴파일하므로 앱이 실행될 때 사용할 수 있다.  
기본적으로 Compose는 기준 프로필과 함께 제공된다.  
프로필을 직접 정의하는 경우 해당 프로필이 앱의 성능을 정말 향상 시키는지 꼭 테스트를 통해 확인해야 한다.  

### 3가지 Compose 단계가 성능에 미치는 영향  
컴포지션: Compose가 표시할 항목을 결정한다, 구성 가능한 함수를 실행하고 UI 트리를 빌드한다.  
레이아웃: Compose가 UI 트리에 있는 각 요소의 크기와 배치를 결정한다.  
그리기: Compose가 실제로 개별 UI 요소를 렌더링 한다.  
Compose는 필요하지 않으면 이러한 단계를 지능적으로 건너뛸 수 있다.  
가능하면 구성 가능한 함수 외부로 계산을 이동한다.  
최대한 오랫동안 상태 읽기를 연기한다.  
상태 읽기를 하위 컴포저블 또는 이후 단계로 이동하면 재구성을 최소화하거나 컴포지션 단계를 완전히 건너뛸 수 있다.  

### 재구성 횟수 가져오기  
Layout Inspector를 사용하여 컴포저블이 재구성되거나 건너뛰는 빈도를 확인할 수 있다.  

### remember를 사용하여 비용이 많이 드는 계산 최소화  
컴포저블의 본문에서 최대한 적은 계산을 실행해야 한다.  
중요한 기법은 remember를 사용하여 계산 결과를 저장하는 것이다.  
이렇게 하면 계산이 한 번 실행되고 필요할 때마다 결과를 가져올 수 있다.  

### 지연 레이아웃 키 사용  
지연 레이아웃은 항목을 지능적으로 재사용하기 위해 최선을 다하므로 필요한 경우에만 항목을 재생성하거나 재구성합니다.  
개발자의 도움이 없으면 Compose가 변경되지 않은 항목이 목록에서 이동된다는 것을 인식하지 못한다.  
결과적으로 Compose는 실제로 변경된 항목은 하나뿐이지만 목록의 모든 항목을 재구성한다.  
각 항목에 안정적인 키를 제공하면 Compose가 불필요한 재구성을 피할 수 있다.  

### derivedStateOf를 사용하여 재구성 제한  
컴포지션에서 상태를 사용할 때의 한 가지 위험은 상태가 빠르게 변경되면 UI가 필요 이상으로 재구성될 수 있다.  
해결 방법은 파생 상태를 사용하는 것이다.  
파생 상태를 사용하면 실제로 재구성을 트리거해야 하는 상태 변경을 Compose에 알릴 수 있다.  

### 최대한 오래 읽기 연기  
상태 변수 읽기는 최대한 오래 연기해야 한다.  
상태 읽기를 연기하면 Compose가 재구성 시 가능한 최소 코드를 다시 실행하도록 할 수 있다.  
개발자는 하위 컴포저블에서 상위 컴포저블의 상태를 읽는 경우 람다 함수에서 상태 읽기를 래핑할 수 있다.  
이렇게 하면 실제로 필요할 때만 읽기가 발생한다.  
스크롤 상태가 변경되면 Compose는 가장 가까운 상위 재구성 범위를 찾아 무효화합니다.  
실제로 사용하는 상태만 읽도록 코드를 변경하면 재구성해야 하는 요소의 수를 줄일 수 있다.  
따라서 스크롤 값이 변경되면 가장 가까운 재구성 범위가 이제 Title 컴포저블이다.  
Compose는 더 이상 전체 Box를 재구성할 필요가 없다.  
람다 버전의 수정자로 전환하면 함수가 레이아웃 단계에서 스크롤 상태를 읽도록 할 수 있다.  
Compose는 컴포지션 단계를 완전히 건너뛰고 레이아웃 단계로 바로 이동할 수 있다.  
자주 변경되는 상태 변수를 수정자에 전달하는 경우 가능하면 람다 버전의 수정자를 사용해야 한다.  
이를 개선하기 위해 람다 기반 수정자(drawBehind)를 사용할 수 있다.  
즉, 그리기 단계에서만 색상 상태를 읽는다.  
따라서 Compose는 컴포지션 및 레이아웃 단계를 완전히 건너뛸수 있다.  
색상이 변경되면 Compose는 그리기 단계로 바로 이동한다.  

### 역방향 쓰기 방지  
Compose에는 개발자가 이미 읽힌 상태에 쓰지 않는다는 핵심 가정이 있다.  
컴포지션에서 상태를 쓰지 않음으로써 역방향 쓰기를 완전히 방지할 수 있다.  
가능하다면 이전의 onClick 예와 같이 이벤트에 대한 응답으로 그리고 람다에서 상태를 쓴다.  